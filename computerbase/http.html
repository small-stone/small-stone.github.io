<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP | 小石头的博客</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="兰生幽谷，不以无人而不芳">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.530d3c12.js" as="script"><link rel="preload" href="/assets/js/2.4b40b10b.js" as="script"><link rel="preload" href="/assets/js/10.f9aa1217.js" as="script"><link rel="prefetch" href="/assets/js/11.c3f7e2c6.js"><link rel="prefetch" href="/assets/js/12.43bff649.js"><link rel="prefetch" href="/assets/js/13.b1eff259.js"><link rel="prefetch" href="/assets/js/14.746a98fb.js"><link rel="prefetch" href="/assets/js/15.bb3d0104.js"><link rel="prefetch" href="/assets/js/16.cb43e51d.js"><link rel="prefetch" href="/assets/js/17.50ad3a18.js"><link rel="prefetch" href="/assets/js/18.fe50ec38.js"><link rel="prefetch" href="/assets/js/19.5b85ddae.js"><link rel="prefetch" href="/assets/js/3.bbe5046a.js"><link rel="prefetch" href="/assets/js/4.b7d0708f.js"><link rel="prefetch" href="/assets/js/5.9e2f4ca7.js"><link rel="prefetch" href="/assets/js/6.c7b54f12.js"><link rel="prefetch" href="/assets/js/7.469ef684.js"><link rel="prefetch" href="/assets/js/8.ca1c59ae.js"><link rel="prefetch" href="/assets/js/9.e9b25eaf.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">小石头的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/computerbase/" class="nav-link router-link-active">
  计算机基础
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  数据结构和算法
</a></div><div class="nav-item"><a href="/javascript/" class="nav-link">
  javaScript
</a></div><div class="nav-item"><a href="/typescript/" class="nav-link">
  TypeScript
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/computerbase/" class="nav-link router-link-active">
  计算机基础
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  数据结构和算法
</a></div><div class="nav-item"><a href="/javascript/" class="nav-link">
  javaScript
</a></div><div class="nav-item"><a href="/typescript/" class="nav-link">
  TypeScript
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/computerbase/" aria-current="page" class="sidebar-link">为什么前端要学计算机基础？</a></li><li><a href="/computerbase/one.html" class="sidebar-link">计算机历史</a></li><li><a href="/computerbase/net.html" class="sidebar-link">互联网历史</a></li><li><a href="/computerbase/tcp.html" class="sidebar-link">TCP/IP</a></li><li><a href="/computerbase/http.html" aria-current="page" class="active sidebar-link">HTTP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/computerbase/http.html#发送-http-请求" class="sidebar-link">发送 HTTP 请求</a></li><li class="sidebar-sub-header"><a href="/computerbase/http.html#服务器端处理-http-请求流程" class="sidebar-link">服务器端处理 HTTP 请求流程</a></li><li class="sidebar-sub-header"><a href="/computerbase/http.html#http-的缓存" class="sidebar-link">HTTP 的缓存</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="http"><a href="#http" class="header-anchor">#</a> HTTP</h1> <p>前端每天都要接触 HTTP，真的了解 HTTP 是什么吗？</p> <p>HTTP 协议，正是建立在 TCP 连接基础之上的。HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。此外，HTTP 也是浏览器使用最广的协议。</p> <h2 id="发送-http-请求"><a href="#发送-http-请求" class="header-anchor">#</a> 发送 HTTP 请求</h2> <p>如果在浏览器输入网址后，会进行如下事情：</p> <ol><li><strong>构建请求</strong></li></ol> <p>首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。</p> <div class="language-tcp extra-class"><pre class="language-text"><code>GET /index.html HTTP1.1
</code></pre></div><ol start="2"><li><strong>查找缓存</strong></li></ol> <p>在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。</p> <p>如果缓存查找失败，就会进入网络请求过程了。</p> <ol start="3"><li><strong>准备 IP 地址和端口</strong></li></ol> <p>因为浏览器使用 HTTP 协议作为应用层协议，用来封装请求的文本信息；并使用 TCP/IP 作传输层协议将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 HTTP 的内容是通过 TCP 的传输数据阶段来实现的</p> <p><img src="https://static001.geekbang.org/resource/image/12/80/1277f342174b23f9442d3b27016d7980.png" alt=""></p> <ul><li>HTTP 网络请求的第一步是和服务器建立 TCP 连接</li> <li>建立 TCP 连接的第一步就是需要准备 IP 地址和端口号。</li> <li>那怎么获取 IP 地址和端口号呢？这得看看我们现在有什么，我们有一个 URL 地址，那么是否可以利用 URL 地址来获取 IP 和端口信息呢？</li></ul> <p>数据包都是通过 IP 地址传输给接收方的。由于 IP 地址是数字标识，比如 8.8.8.8, 难以记忆，但使用域名 google.com 就好记多了，所以基于这个需求又出现了一个服务，负责把域名和 IP 地址做一一映射关系。这套域名映射为 IP 的系统就叫做“域名系统”，简称 DNS（Domain Name System）。</p> <p>所以我们回头看，第一步浏览器会请求 DNS 返回域名对应的 IP。当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。</p> <p>拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。</p> <ol start="4"><li><strong>等待 TCP 队列</strong></li></ol> <p>现在已经把端口和 IP 地址都准备好了，那么下一步是不是可以建立 TCP 连接了呢？</p> <p>答案依然是“不行”。Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。</p> <ol start="5"><li><strong>建立 TCP 连接</strong></li></ol> <p>排队等待结束之后，终于可以快乐地和服务器握手了，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。</p> <ol start="6"><li><strong>发送 HTTP 请求</strong></li></ol> <p>一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。</p> <p><img src="https://static001.geekbang.org/resource/image/b8/d7/b8993c73f7b60feb9b8bd147545c47d7.png" alt=""></p> <p>首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。</p> <p>在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。</p> <h2 id="服务器端处理-http-请求流程"><a href="#服务器端处理-http-请求流程" class="header-anchor">#</a> 服务器端处理 HTTP 请求流程</h2> <p>历经千辛万苦，HTTP 的请求信息终于被送达了服务器。接下来，服务器会根据浏览器的请求信息来准备相应的内容。</p> <ol><li><strong>返回请求</strong></li></ol> <p>一旦服务器处理结束，便可以返回数据给浏览器了，用工具软件 curl 来查看返回请求数据</p> <div class="language-curl extra-class"><pre class="language-text"><code>curl -i  https://www.baidu.com/
</code></pre></div><p><img src="https://img1.imgtp.com/2022/03/22/nVloivs1.png" alt="1647923424358.png"></p> <p>首先服务器会返回响应行，包括协议版本和状态码。</p> <p>但并不是所有的请求都可以被服务器处理的，那么一些无法处理或者处理出错的信息，怎么办呢？服务器会通过请求行的状态码来告诉浏览器它的处理结果，比如：最常用的状态码是 200，表示处理成功；如果没有找到页面，则会返回 404。</p> <p>随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容。以上这些就是服务器响应浏览器的具体过程。</p> <ol start="2"><li><strong>断开连接</strong></li></ol> <p>通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：</p> <div class="language- extra-class"><pre class="language-text"><code>Connection:Keep-Alive
</code></pre></div><p>那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。</p> <ol start="3"><li><strong>重定向</strong></li></ol> <p>在控制台输入如下命令</p> <div class="language-curl extra-class"><pre class="language-text"><code>curl -i  https://baidu.com/
</code></pre></div><p>注意这里输入的参数是-I，和-i 不一样，-I 表示只需要获取响应头和响应行数据，而不需要获取响应体的数据，最终返回的数据如下图所示： <img src="https://img1.imgtp.com/2022/03/22/leP6HvhQ.png" alt="1647923820055.png"> 响应行返回的状态码是 301，状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。</p> <h2 id="http-的缓存"><a href="#http-的缓存" class="header-anchor">#</a> HTTP 的缓存</h2> <p><img src="https://static001.geekbang.org/resource/image/5f/08/5fc2f88a04ee0fc41a808f3481287408.png" alt=""></p> <p>首先看一下缓存相关 header</p> <ul><li>Expires 响应头，代表该资源的过期时间。</li> <li>Cache-Control 请求/响应头，缓存控制字段，精确控制缓存策略。</li> <li>If-Modified-Since 请求头，资源最近修改时间，由浏览器告诉服务器。</li> <li>Last-Modified 响应头，资源最近修改时间，由服务器告诉浏览器。</li> <li>Etag 响应头，资源标识，由服务器告诉浏览器。</li> <li>If-None-Match 请求头，缓存资源标识，由浏览器告诉服务器。</li></ul> <p>配对使用的字段：</p> <ul><li>Etag 和 If-None-Match</li> <li>If-Modified-Since 和 Last-Modified</li></ul> <h3 id="expires"><a href="#expires" class="header-anchor">#</a> Expires</h3> <p>服务器和浏览器约定文件过期时间，用 Expires 字段来控制，时间是 GMT 格式的标准时间，如 Fri, 01 Jan 1990 00:00:00 GMT。</p> <p>优点：</p> <ol><li>在过期时间以内，为用户省了很多流量。</li> <li>减少了服务器重复读取磁盘文件的压力。</li> <li>缓存过期后，能够得到最新的文件。</li></ol> <p>缺点：</p> <ol><li>缓存过期以后，服务器不管 a.js 有没有变化，都会再次读取 a.js 文件，并返给浏览器。</li> <li>客户端时间可以篡改</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/computerbase/tcp.html" class="prev">
        TCP/IP
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.530d3c12.js" defer></script><script src="/assets/js/2.4b40b10b.js" defer></script><script src="/assets/js/10.f9aa1217.js" defer></script>
  </body>
</html>
