(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{412:function(t,v,a){"use strict";a.r(v);var _=a(56),s=Object(_.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"http"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" HTTP")]),t._v(" "),a("p",[t._v("前端每天都要接触 HTTP，真的了解 HTTP 是什么吗？")]),t._v(" "),a("p",[t._v("HTTP 协议，正是建立在 TCP 连接基础之上的。HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。此外，HTTP 也是浏览器使用最广的协议。")]),t._v(" "),a("h2",{attrs:{id:"发送-http-请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#发送-http-请求"}},[t._v("#")]),t._v(" 发送 HTTP 请求")]),t._v(" "),a("p",[t._v("如果在浏览器输入网址后，会进行如下事情：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("构建请求")])])]),t._v(" "),a("p",[t._v("首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。")]),t._v(" "),a("div",{staticClass:"language-tcp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("GET /index.html HTTP1.1\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[a("strong",[t._v("查找缓存")])])]),t._v(" "),a("p",[t._v("在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。")]),t._v(" "),a("p",[t._v("如果缓存查找失败，就会进入网络请求过程了。")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[a("strong",[t._v("准备 IP 地址和端口")])])]),t._v(" "),a("p",[t._v("因为浏览器使用 HTTP 协议作为应用层协议，用来封装请求的文本信息；并使用 TCP/IP 作传输层协议将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 HTTP 的内容是通过 TCP 的传输数据阶段来实现的")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/12/80/1277f342174b23f9442d3b27016d7980.png",alt:""}})]),t._v(" "),a("ul",[a("li",[t._v("HTTP 网络请求的第一步是和服务器建立 TCP 连接")]),t._v(" "),a("li",[t._v("建立 TCP 连接的第一步就是需要准备 IP 地址和端口号。")]),t._v(" "),a("li",[t._v("那怎么获取 IP 地址和端口号呢？这得看看我们现在有什么，我们有一个 URL 地址，那么是否可以利用 URL 地址来获取 IP 和端口信息呢？")])]),t._v(" "),a("p",[t._v("数据包都是通过 IP 地址传输给接收方的。由于 IP 地址是数字标识，比如 8.8.8.8, 难以记忆，但使用域名 google.com 就好记多了，所以基于这个需求又出现了一个服务，负责把域名和 IP 地址做一一映射关系。这套域名映射为 IP 的系统就叫做“域名系统”，简称 DNS（Domain Name System）。")]),t._v(" "),a("p",[t._v("所以我们回头看，第一步浏览器会请求 DNS 返回域名对应的 IP。当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。")]),t._v(" "),a("p",[t._v("拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。")]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[a("strong",[t._v("等待 TCP 队列")])])]),t._v(" "),a("p",[t._v("现在已经把端口和 IP 地址都准备好了，那么下一步是不是可以建立 TCP 连接了呢？")]),t._v(" "),a("p",[t._v("答案依然是“不行”。Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。")]),t._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[a("strong",[t._v("建立 TCP 连接")])])]),t._v(" "),a("p",[t._v("排队等待结束之后，终于可以快乐地和服务器握手了，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。")]),t._v(" "),a("ol",{attrs:{start:"6"}},[a("li",[a("strong",[t._v("发送 HTTP 请求")])])]),t._v(" "),a("p",[t._v("一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/b8/d7/b8993c73f7b60feb9b8bd147545c47d7.png",alt:""}})]),t._v(" "),a("p",[t._v("首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。")]),t._v(" "),a("p",[t._v("在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。")]),t._v(" "),a("h2",{attrs:{id:"服务器端处理-http-请求流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务器端处理-http-请求流程"}},[t._v("#")]),t._v(" 服务器端处理 HTTP 请求流程")]),t._v(" "),a("p",[t._v("历经千辛万苦，HTTP 的请求信息终于被送达了服务器。接下来，服务器会根据浏览器的请求信息来准备相应的内容。")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("返回请求")])])]),t._v(" "),a("p",[t._v("一旦服务器处理结束，便可以返回数据给浏览器了，用工具软件 curl 来查看返回请求数据")]),t._v(" "),a("div",{staticClass:"language-curl extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("curl -i  https://www.baidu.com/\n")])])]),a("p",[a("img",{attrs:{src:"https://img1.imgtp.com/2022/03/22/nVloivs1.png",alt:"1647923424358.png"}})]),t._v(" "),a("p",[t._v("首先服务器会返回响应行，包括协议版本和状态码。")]),t._v(" "),a("p",[t._v("但并不是所有的请求都可以被服务器处理的，那么一些无法处理或者处理出错的信息，怎么办呢？服务器会通过请求行的状态码来告诉浏览器它的处理结果，比如：最常用的状态码是 200，表示处理成功；如果没有找到页面，则会返回 404。")]),t._v(" "),a("p",[t._v("随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容。以上这些就是服务器响应浏览器的具体过程。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("strong",[t._v("断开连接")])])]),t._v(" "),a("p",[t._v("通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Connection:Keep-Alive\n")])])]),a("p",[t._v("那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[a("strong",[t._v("重定向")])])]),t._v(" "),a("p",[t._v("在控制台输入如下命令")]),t._v(" "),a("div",{staticClass:"language-curl extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("curl -i  https://baidu.com/\n")])])]),a("p",[t._v("注意这里输入的参数是-I，和-i 不一样，-I 表示只需要获取响应头和响应行数据，而不需要获取响应体的数据，最终返回的数据如下图所示： "),a("img",{attrs:{src:"https://img1.imgtp.com/2022/03/22/leP6HvhQ.png",alt:"1647923820055.png"}}),t._v(" 响应行返回的状态码是 301，状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。")]),t._v(" "),a("h2",{attrs:{id:"http-的缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-的缓存"}},[t._v("#")]),t._v(" HTTP 的缓存")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/5f/08/5fc2f88a04ee0fc41a808f3481287408.png",alt:""}})]),t._v(" "),a("p",[t._v("首先看一下缓存相关 header")]),t._v(" "),a("ul",[a("li",[t._v("Expires 响应头，代表该资源的过期时间。")]),t._v(" "),a("li",[t._v("Cache-Control 请求/响应头，缓存控制字段，精确控制缓存策略。")]),t._v(" "),a("li",[t._v("If-Modified-Since 请求头，资源最近修改时间，由浏览器告诉服务器。")]),t._v(" "),a("li",[t._v("Last-Modified 响应头，资源最近修改时间，由服务器告诉浏览器。")]),t._v(" "),a("li",[t._v("Etag 响应头，资源标识，由服务器告诉浏览器。")]),t._v(" "),a("li",[t._v("If-None-Match 请求头，缓存资源标识，由浏览器告诉服务器。")])]),t._v(" "),a("p",[t._v("配对使用的字段：")]),t._v(" "),a("ul",[a("li",[t._v("Etag 和 If-None-Match")]),t._v(" "),a("li",[t._v("If-Modified-Since 和 Last-Modified")])]),t._v(" "),a("h3",{attrs:{id:"expires"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[t._v("#")]),t._v(" Expires")]),t._v(" "),a("p",[t._v("服务器和浏览器约定文件过期时间，用 Expires 字段来控制，时间是 GMT 格式的标准时间，如 Fri, 01 Jan 1990 00:00:00 GMT。")]),t._v(" "),a("p",[t._v("优点：")]),t._v(" "),a("ol",[a("li",[t._v("在过期时间以内，为用户省了很多流量。")]),t._v(" "),a("li",[t._v("减少了服务器重复读取磁盘文件的压力。")]),t._v(" "),a("li",[t._v("缓存过期后，能够得到最新的文件。")])]),t._v(" "),a("p",[t._v("缺点：")]),t._v(" "),a("ol",[a("li",[t._v("缓存过期以后，服务器不管 a.js 有没有变化，都会再次读取 a.js 文件，并返给浏览器。")]),t._v(" "),a("li",[t._v("客户端时间可以篡改")])])])}),[],!1,null,null,null);v.default=s.exports}}]);